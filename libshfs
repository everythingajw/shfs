#!/bin/bash

# Size of each field an inode
export INODE_FIELD_FILE_LENGTH_SIZE=2
export INODE_FIELD_PERMISSIONS_SIZE=2
export INODE_FIELD_USER_ID_SIZE=4
export INODE_FIELD_GROUP_ID_SIZE=4
export INODE_FIELD_LAST_MODIFIED_SIZE=7
export INODE_FIELD_NAME_SIZE=256

# Offset of each field in an inode
export INODE_FIELD_FILE_LENGTH_OFFSET=0
export INODE_FIELD_PERMISSIONS_OFFSET="$INODE_FIELD_FILE_LENGTH_SIZE"
export INODE_FIELD_USER_ID_OFFSET="$((INODE_FIELD_PERMISSIONS_OFFSET + INODE_FIELD_PERMISSIONS_SIZE))"
export INODE_FIELD_GROUP_ID_OFFSET="$((INODE_FIELD_USER_ID_OFFSET + INODE_FIELD_USER_ID_SIZE))"
export INODE_FIELD_LAST_MODIFIED_OFFSET="$((INODE_FIELD_GROUP_ID_OFFSET + INODE_FIELD_GROUP_ID_SIZE))"
export INODE_FIELD_NAME_OFFSET="$((INODE_FIELD_LAST_MODIFIED_OFFSET + INODE_FIELD_LAST_MODIFIED_SIZE))"

# The entire filesystem has a 2-byte header that stores the number of inodes on the filesystem.
export FILESYSTEM_HEADER_SIZE=2

# Total size of each inode
export INODE_SIZE="$((INODE_FIELD_FILE_LENGTH_SIZE
                      + INODE_FIELD_PERMISSIONS_SIZE
                      + INODE_FIELD_USER_ID_SIZE
                      + INODE_FIELD_GROUP_ID_SIZE
                      + INODE_FIELD_LAST_MODIFIED_SIZE
                      + INODE_FIELD_NAME_SIZE))"

# Each file gets one 2048-byte block.
export FILE_BLOCK_SIZE=2048

export FIRST_INODE_NUMBER=1

# - 2 byte unsigned inode number
# - 2 byte unsigned permissions (read, write, execute for user, group, other)
# - 4 byte unsigned user id
# - 4 byte unsigned group id
# - 2 byte unsigned file length
# - 7 byte signed last modification time
# - 256 byte file name

export PERMISSIONS_USER_READ="$((0400))"
export PERMISSIONS_USER_WRITE="$((0200))"
export PERMISSIONS_USER_EXECUTE="$((0100))"

export PERMISSIONS_GROUP_READ="$((040))"
export PERMISSIONS_GROUP_WRITE="$((020))"
export PERMISSIONS_GROUP_EXECUTE="$((010))"

export PERMISSIONS_OTHER_READ="$((04))"
export PERMISSIONS_OTHER_WRITE="$((02))"
export PERMISSIONS_OTHER_EXECUTE="$((01))"

eecho() {
    echo "$@" >&2
}
export -f eecho

hex2decimal() {
    local n="$1"
    if [ -z "$n" ]
    then
        return 0
    fi
    local slice="${n:0:2}"
    if [ "${slice,,}"  != '0x' ]
    then
        n="0x$n"
    fi
    printf "%d" "$n"
}
export -f hex2decimal

hex2octal() {
    printf "%o" "$(hex2decimal "$1")"
}
export -f hex2octal

octal2decimal() {
    local n="$1"
    if [ -z "$n" ]
    then
        return 0
    fi
    if [[ ! "$n" =~ ^0 ]]
    then
        n="0$n"
    fi
    printf "%d" "$n"
}
export -f octal2decimal

_hexdump_plain() {
    hexdump --no-squeezing --format '/1 "%02x"'  # "$@"
}
export -f _hexdump_plain

qdd() {
    dd status=none "$@"
}
export -f qdd

# Gets the address of the beginning of the given inode.
# This function *only* does math. It doesn't care if the inode number is valid for a particular filesystem.
_offset_of_inode() {
    local inode_num="$1"
    inode_num="$((inode_num - FIRST_INODE_NUMBER))"
    printf "%d" "$(( FILESYSTEM_HEADER_SIZE + (inode_num * INODE_SIZE) ))"
}
export -f _offset_of_inode

fs_write() {
    qdd conv=sparse,notrunc of="$1" "${@:2}"
}
export -f fs_write

get_num_inodes() {
    local filesystem="$1"
    if [ -z "$filesystem" ]
    then
        return 1
    fi

    local n
    n="$(qdd if="$filesystem" bs=1 count=2 | _hexdump_plain)"
    hex2decimal "$n"
}
export -f get_num_inodes

is_valid_inode_number() {
    local filesystem="$1"
    local inode_num="$2"
    if [ -z "$filesystem" ] || ! [[ "$inode_num" =~ ^[0-9]+$ ]]
    then
        return 1
    fi
    local total_inodes
    total_inodes="$(get_num_inodes "$filesystem")"

    if [ "$inode_num" -lt "$FIRST_INODE_NUMBER" ] || [ "$((inode_num - FIRST_INODE_NUMBER))" -ge "$total_inodes" ]
    then
        return 1
    fi

    return 0
}

is_valid_file_name() {
    [ -n "$1" ] && [ "${#1}" -le "$INODE_FIELD_NAME_SIZE" ] && ! echo "$1" | grep -qe '/'
}

get_file_name() {
    local filesystem="$1"
    local inode_num="$2"
    if [ -z "$filesystem" ] || ! is_valid_inode_number "$filesystem" "$inode_num"
    then
        return 1
    fi

    local inode_offset="$(( FILESYSTEM_HEADER_SIZE + ((inode_num - FIRST_INODE_NUMBER) * INODE_SIZE) ))"
    local real_name_offset="$((inode_offset + INODE_FIELD_NAME_OFFSET))"
    qdd if="$filesystem" bs=1 count="$INODE_FIELD_NAME_SIZE" skip="$real_name_offset" | cut -d / -f 1 | tr -d '\000'
}
export -f get_file_name

# Sets the name of a file.
#
# Warning: this function assumes all parameters are valid!
_set_file_name_unchecked() {
    local filesystem="$1"
    local inode_num="$2"
    local name="$3"

    local offset
    offset="$(_offset_of_inode "$inode_num")"
    offset="$((offset + INODE_FIELD_NAME_OFFSET))"
    printf "%s" "$name" | fs_write "$filesystem" bs=1 count="${#name}" seek="$offset"
}

set_file_name() {
    local filesystem="$1"
    local inode_num="$2"
    local name="$3"
    if [ -z "$filesystem" ] || ! is_valid_inode_number "$filesystem" "$inode_num" || ! is_valid_file_name "$name"
    then
        return 1
    fi

    # Need to slash-terminate the name if it's short
    if [ "${#name}" -lt "$INODE_FIELD_NAME_SIZE" ]
    then
        name="${name}/"
    fi

    _set_file_name_unchecked "$filesystem" "$inode_num" "$name"
}
export -f set_file_name

# Gets the first free inode on the filesystem.
# Returns:
#   0 on success
#   1 if invalid arguments
#   2 if no inodes are free
get_first_free_inode() {
    local filesystem="$1"
    if [ -z "$filesystem" ]
    then
        return 1
    fi
    local i=0
    local total_inodes
    total_inodes="$(get_num_inodes "$filesystem")"
    local filename
    while [ "$i" -lt "$total_inodes" ]
    do
        local real_inode_number="$((i + FIRST_INODE_NUMBER))"
        filename="$(get_file_name "$filesystem" "$real_inode_number")"
        if [ -z "$filename" ]
        then
            return 0
        fi
        i="$((i + 1))"
    done

    # Filesystem is full
    return 2
}
export -f get_first_free_inode

get_file_length() {
    local filesystem="$1"
    local inode_num="$2"
    if [ -z "$filesystem" ] || ! is_valid_inode_number "$filesystem" "$inode_num"
    then
        return 1
    fi

    local inode_start_offset="$((FILESYSTEM_HEADER_SIZE + ((inode_num - FIRST_INODE_NUMBER) * INODE_SIZE)))"
    local field_offset="$((2 + 2 + 4 + 4))"
    local real_offset="$((inode_start_offset + field_offset))"
    local n
    n="$(qdd if="$filesystem" bs=1 count=2 skip="$real_offset" | _hexdump_plain)"
    hex2decimal "$n"
}
export -f get_file_length

get_data_start_for_inode() {
    local filesystem="$1"
    local inode_num="$2"
    if [ -z "$filesystem" ] || ! is_valid_inode_number "$filesystem" "$inode_num"
    then
        return 1
    fi

    local total_inodes
    total_inodes="$(get_num_inodes "$filesystem")"

    # The first byte of "real data" on the entire disk
    local disk_data_start="$((FILESYSTEM_HEADER_SIZE + (INODE_SIZE * total_inodes)))"

    # Since data blocks are laid out sequentially, we just have to seek ahead the appropriate number of bytes.
    # Compute where the target data starts relative to the beginning of the "real data" on the disk.
    local inode_num_zero="$((inode_num - FIRST_INODE_NUMBER))"
    local target_data_offset="$((inode_num_zero * FILE_BLOCK_SIZE))"

    echo "$((disk_data_start + target_data_offset))"
    return 0
}
export -f get_data_start_for_inode

set_file_length() {
    local filesystem="$1"
    local inode_num="$2"
    local length="$3"
    if [ -z "$filesystem" ] || ! is_valid_inode_number "$filesystem" "$inode_num"
    then
        return 1
    fi

    if [[ ! "$length" =~ ^[0-9]+$ ]] || [ "$length" -lt 0 ] || [ "$length" -gt "$FILE_BLOCK_SIZE" ]
    then
        return 1
    fi

    local inode_start
    inode_start="$(_offset_of_inode "$inode_num")"
    local file_size_start="$((inode_start + 2 + 2 + 4 + 4))"

    local hex="$(printf '%04x' "$length")"
    local high="${hex:0:2}"
    local low="${hex:2:2}"

    printf "\x${high}\x${low}" | fs_write "$filesystem" seek="$file_size_start" bs=1 count=2
}
export -f set_file_length

# Searches the filesystem for a file with the given name.
# If a file with the requested name is found, its inode number is returned.
# If no such file can be found, an empty string is returned.
find_file() {
    local filesystem="$1"
    local needle="$2"
    if [ -z "$filesystem" ] || [ -z "$needle" ]
    then
        return 1
    fi

    local total_inodes
    total_inodes="$(get_num_inodes "$filesystem")"
    local i=0
    while [ "$i" -lt "$total_inodes" ]
    do
        local inode_num="$((i + FIRST_INODE_NUMBER))"
        local curr_filename
        curr_filename="$(get_file_name "$filesystem" "$inode_num")"
        if [ "$curr_filename" = "$needle" ]
        then
            echo "$inode_num"
            return 0
        fi
        i="$((i + 1))"
    done

    return 0
}
export -f find_file

get_permissions() {
    local filesystem="$1"
    local inode_num="$2"
    if [ -z "$filesystem" ] || ! is_valid_inode_number "$filesystem" "$inode_num"
    then
        return 1
    fi

    local offset
    offset="$(_offset_of_inode "$inode_num")"
    offset="$((offset + INODE_FIELD_PERMISSIONS_OFFSET))"
    hex2decimal "$(qdd if="$filesystem" bs=1 count="$INODE_FIELD_PERMISSIONS_SIZE" skip="$offset" | _hexdump_plain)"
}
export -f get_permissions

set_permissions() {
    local filesystem="$1"
    local inode_num="$2"
    local permissions=""
    if [ "$#" -ge 3 ]
    then
        permissions="$3"
    fi
    if [ -z "$filesystem" ] || ! is_valid_inode_number "$filesystem" "$inode_num"
    then
        return 1
    fi

    if [ -z "$permissions" ]
    then
        permissions="$((0777 & (~ $(umask) ) ))"
    fi

    if [ "$permissions" -lt 0 ] || [ "$permissions" -gt "$(octal2decimal 0777)" ]
    then
        return 1
    fi

    local offset
    offset="$(_offset_of_inode "$inode_num")"
    offset="$((offset + INODE_FIELD_PERMISSIONS_OFFSET))"
    local hex
    hex="$(printf "%04x" "$permissions")"
    printf "\x${hex:0:2}\x${hex:2:2}" | fs_write "$filesystem" bs=1 count="$INODE_FIELD_PERMISSIONS_SIZE" seek="$offset"
}
export -f set_permissions

get_file_owner() {
    local filesystem="$1"
    local inode_num="$2"
    if [ -z "$filesystem" ] || ! is_valid_inode_number "$filesystem" "$inode_num"
    then
        return 1
    fi

    local offset
    offset="$(_offset_of_inode "$inode_num")"
    offset="$((offset + INODE_FIELD_USER_ID_OFFSET))"
    hex2decimal "$(qdd if="$filesystem" bs=1 count="$INODE_FIELD_USER_ID_SIZE" skip="$offset" | _hexdump_plain)"
}
export -f get_file_owner

set_file_owner() {
    local filesystem="$1"
    local inode_num="$2"
    local uid=""
    if [ "$#" -ge 3 ]
    then
        gid="$3"
    fi
    if [ -z "$filesystem" ] || ! is_valid_inode_number "$filesystem" "$inode_num"
    then
        return 1
    fi

    if [ -z "$uid" ]
    then
        uid="$(id -u)"
    fi

    if [ "$uid" -lt 0 ] || [ "$uid" -gt "$(echo '(2^32)-1' | bc)" ]
    then
        return 1
    fi

    local offset
    offset="$(_offset_of_inode "$inode_num")"
    offset="$((offset + INODE_FIELD_USER_ID_OFFSET))"
    local hex
    hex="$(printf "%08x" "$uid")"
    printf "\x${hex:0:2}\x${hex:2:2}\x${hex:4:2}\x${hex:6:2}" | fs_write "$filesystem" bs=1 count="$INODE_FIELD_USER_ID_SIZE" seek="$offset"
}
export -f set_file_owner

get_file_group() {
    local filesystem="$1"
    local inode_num="$2"
    local gid=""
    if [ "$#" -ge 3 ]
    then
        gid="$3"
    fi
    if [ -z "$filesystem" ] || ! is_valid_inode_number "$filesystem" "$inode_num"
    then
        return 1
    fi

    local offset
    offset="$(_offset_of_inode "$inode_num")"
    offset="$((offset + INODE_FIELD_GROUP_ID_OFFSET))"
    hex2decimal "$(qdd if="$filesystem" bs=1 count="$INODE_FIELD_USER_ID_SIZE" skip="$offset" | _hexdump_plain)"
}
export -f get_file_group

set_file_group() {
    local filesystem="$1"
    local inode_num="$2"
    local gid="$3"
    if [ -z "$filesystem" ] || ! is_valid_inode_number "$filesystem" "$inode_num"
    then
        return 1
    fi

    if [ -z "$gid" ]
    then
        gid="$(id -g)"
    fi

    if [ "$gid" -lt 0 ] || [ "$gid" -gt "$(echo '(2^32)-1' | bc)" ]
    then
        return 1
    fi

    local offset
    offset="$(_offset_of_inode "$inode_num")"
    offset="$((offset + INODE_FIELD_GROUP_ID_OFFSET))"
    local hex
    hex="$(printf "%08x" "$gid")"
    printf "\x${hex:0:2}\x${hex:2:2}\x${hex:4:2}\x${hex:6:2}" | fs_write "$filesystem" bs=1 count="$INODE_FIELD_GROUP_ID_SIZE" seek="$offset"
}
export -f set_file_group

# Tests if a user can access a file.
#
# Parameters:
#  1: filesystem path
#  2: inode number
#  3: kind of access: one of "r", "w", "x"
#
# Returns 0 if the user can access the file in the given way, 1 otherwise.
# Returns 2 on invalid parameters.
can_access() {
    local filesystem="$1"
    local inode_num="$2"
    local kind="$3"
    kind="${kind,,}"

    if [ -z "$filesystem" ] || ! is_valid_inode_number "$filesystem" "$inode_num" || [[ ! "$kind" =~ ^[rwx]$ ]]
    then
        return 2
    fi

    # We're going to do something here that's not to be expected with this filesystem: consider performance.
    # Don't get the file owner/group until we actually need it. No need to get group information if the user
    # permissions match.

    local uid
    uid="$(id -u)"

    # Root can always do anything
    if [ "$uid" = 0 ]
    then
        return 0
    fi

    local permissions
    permissions="$(get_permissions "$filesystem" "$inode_num")"

    local file_owner
    file_owner="$(get_file_owner "$filesystem" "$inode_num")"

    local mask

    # Default to other. We'll get more specific if needed.
    case "$kind" in
        r) mask="$PERMISSIONS_OTHER_READ";;
        w) mask="$PERMISSIONS_OTHER_WRITE";;
        x) mask="$PERMISSIONS_OTHER_EXECUTE";;
    esac

    if [ "$uid" = "$file_owner" ]
    then
        case "$kind" in
            r) mask="$PERMISSIONS_USER_READ";;
            w) mask="$PERMISSIONS_USER_WRITE";;
            x) mask="$PERMISSIONS_USER_EXECUTE";;
        esac
    else
        local gid
        gid="$(id -g)"

        local file_group
        file_group="$(get_file_group "$filesystem" "$inode_num")"

        if [ "$gid" = "$file_group" ]
        then
            case "$kind" in
                r) mask="$PERMISSIONS_GROUP_READ";;
                w) mask="$PERMISSIONS_GROUP_WRITE";;
                x) mask="$PERMISSIONS_GROUP_EXECUTE";;
            esac
        fi
    fi

    if [ "$((permissions & mask))" = 0 ]
    then
        return 1
    else
        return 0
    fi
}
export -f can_access

deallocate_inode() {
    local filesystem="$1"
    local inode_num="$2"
    if [ -z "$filesystem" ] || ! is_valid_inode_number "$filesystem" "$inode_num"
    then
        return 1
    fi

    # The only thing that indicates an inode is available is if the first character of the filename is a slash.
    _set_file_name_unchecked "$filesystem" "$inode_num" '/'
}
export -f deallocate_inode
